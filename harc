#!/bin/bash
set -e
# Download data
# DATA_DIR="data/"

usage()
{
cat << EOF

HARC compression tool for genomic reads. Works on fixed length reads of length less than 256.

Usage: 
Compression - compresses FASTQ reads. Output written to .harc file
./harc -c FASTQ_file [-p] [-t num_threads] [-q]
-p Preserve order of reads
-t num_threads - Default 8
-q Write quality values and Read IDs to .quality and .id files, respectively. Quality values and IDs are appropriately reordered if -p is not specified. 

Decompression - decompresses reads. Output written to .dna.d file
./harc -d HARC_file [-p] [-t num_threads] [-m max_memory]
-p Get reads in original order (slower). Only applicable if -p was used during compression.
-t num_threads - Default 8
-m max_memory - Controls memory-time tradeoff for decompression with -p. Specify max memory in GB (minimum 3 GB for 3 threads). e.g. -m 10 for 10 GB maximum memory. Default: 7 GB (note: less than 3 GB memory required if -p not specified)

Help (this message)
./harc -h

See README and more supplementary information at:
https://github.com/shubhamchandak94/HARC

EOF
exit 0
}

compress()
{
	harcdir=$(dirname $BASH_SOURCE)
	pathname=$(dirname $filename)
	tempdir=$(mktemp -d -p $pathname)
	trap "rm -rf $tempdir" EXIT
	echo "*** Preprocessing ***"
	echo $filename
	readlen="$(head -2 $filename | tail -1 | wc -L)"
	if (($readlen > 256));then
		echo "Maximum read length exceeded" 
		exit 1
	fi
	#calculate bitset sizes for reorder and encoder
	bitset_size_reorder=$(((2*$readlen-1)/64*64+64))	
	bitset_size_encoder=$(((3*$readlen-1)/64*64+64))	
	
	if [[ $paired_end == "True" ]];then
		if [[ $filename_2 == '' ]];then
			echo "Second file needed in PE mode"
			exit 1
		fi
		echo $filename_2
		./$harcdir/bin/preprocess_pe.out $filename $filename_2 $tempdir $preserve_quality $readlen
	else
		./$harcdir/bin/preprocess.out $filename $tempdir $preserve_quality $readlen
	fi
	./$harcdir/bin/reorder/reorder_$bitset_size_reorder".out" $tempdir $readlen $num_thr
	rm $tempdir/input_clean.dna
	./$harcdir/bin/encoder/encoder_$bitset_size_encoder".out" $tempdir $readlen $num_thr
	rm $tempdir/input_N.dna

	#remove temporary files
	rm $tempdir/temp.dna
	rm $tempdir/tempflag.txt
	rm $tempdir/temppos.txt
	rm $tempdir/read_rev.txt
	
	#tar files produced by the threads
	mkdir -p $tempdir/read_noise
	mv $tempdir/read_noise.txt* $tempdir/read_noise
	mkdir -p $tempdir/read_noisepos
	mv $tempdir/read_noisepos.txt* $tempdir/read_noisepos
	mkdir -p $tempdir/read_pos
	mv $tempdir/read_pos.txt* $tempdir/read_pos
	mkdir -p $tempdir/read_seq
	mv $tempdir/read_seq.txt* $tempdir/read_seq
	mkdir -p $tempdir/read_rev
	mv $tempdir/read_rev.txt* $tempdir/read_rev

	tar -cf	$tempdir/read_noise.tar -C $tempdir/read_noise .
	tar -cf	$tempdir/read_noisepos.tar -C $tempdir/read_noisepos .
	tar -cf	$tempdir/read_pos.tar -C $tempdir/read_pos .
	tar -cf	$tempdir/read_seq.tar -C $tempdir/read_seq .
	tar -cf	$tempdir/read_rev.tar -C $tempdir/read_rev .
	
	rm -r $tempdir/read_noise
	rm -r $tempdir/read_noisepos
	rm -r $tempdir/read_pos
	rm -r $tempdir/read_seq
	rm -r $tempdir/read_rev
	
	#compress and create tarball
	./$harcdir/bin/bsc e $tempdir/read_pos.tar $tempdir/read_pos.tar.bsc -b64p -t$num_thr
	./$harcdir/bin/bsc e $tempdir/read_noise.tar $tempdir/read_noise.tar.bsc -b64p -t$num_thr 
	7z a $tempdir/read_noisepos.tar.7z $tempdir/read_noisepos.tar -mmt=$numt_thr
	./$harcdir/bin/bsc e $tempdir/unaligned_N.txt $tempdir/unaligned_N.txt.bsc -b64p -t$num_thr
	7z a $tempdir/read_meta.txt.7z $tempdir/read_meta.txt -mmt=$num_thr
	7z a $tempdir/read_rev.tar.7z $tempdir/read_rev.tar -mmt=$num_thr
	./$harcdir/bin/bsc e $tempdir/read_seq.tar $tempdir/read_seq.tar.bsc -b64p -t$num_thr 
	./$harcdir/bin/bsc e $tempdir/unaligned_singleton.txt $tempdir/unaligned_singleton.txt.bsc -b64p -t$num_thr 
	rm $tempdir/*.txt $tempdir/*.dna $tempdir/*.tar 
	if [[ $paired_end == "True" ]];then
		./$harcdir/bin/pe_encode.out $tempdir	
		if [[ $preserve_quality == "True" ]];then
			echo "Reordering quality values and ids"
			./$harcdir/bin/reorder_quality_pe.out $tempdir $readlen
			mv $tempdir/output_1.quality $pathname/$(basename "$filename" _1.fastq)_1.quality
			mv $tempdir/output_2.quality $pathname/$(basename "$filename" _1.fastq)_2.quality
			rm $tempdir/*.quality
			mv $tempdir/output_1.id $pathname/$(basename "$filename" _1.fastq)_1.id
			mv $tempdir/output_2.id $pathname/$(basename "$filename" _1.fastq)_2.id
			rm $tempdir/*.id
			echo "Done!"
		fi
		7z a $tempdir/read_order_paired.bin.7z $tempdir/read_order_paired.bin -mmt=$num_thr
		7z a $tempdir/read_paired_flag_first.bin.7z $tempdir/read_paired_flag_first.bin -mmt=$num_thr
	elif [[ $preserve_order == "True" ]];then
		./$harcdir/bin/pack_order.out $tempdir	
		7z a $tempdir/read_order.bin.7z $tempdir/read_order.bin -mmt=$num_thr
		if [[ $preserve_quality == "True" ]];then
			mv $tempdir/input.quality $pathname/$(basename "$filename" .fastq).quality
			mv $tempdir/input.id $pathname/$(basename "$filename" .fastq).id
		fi
	else
		if [[ $preserve_quality == "True" ]];then
			echo "Reordering quality values and ids"
			./$harcdir/bin/reorder_quality.out $tempdir $readlen
			mv $tempdir/output.quality $pathname/$(basename "$filename" .fastq).quality
			rm $tempdir/*.quality
			mv $tempdir/output.id $pathname/$(basename "$filename" .fastq).id
			rm $tempdir/*.id
			echo "Done!"
		fi	
	fi
	7z a $tempdir/numreads.bin.7z $tempdir/numreads.bin
	rm $tempdir/*.bin
	rm $tempdir/*.singleton
	if [[ $paired_end == "True" ]];then
		tar -cf $pathname/$(basename "$filename" _1.fastq).harc -C $tempdir .
	else
		tar -cf $pathname/$(basename "$filename" .fastq).harc -C $tempdir .
	fi
	rm -r $tempdir/
}

decompress()
{
	echo "Decompression ..."
	harcdir=$(dirname $BASH_SOURCE)
	pathname=$(dirname $filename)
	tempdir=$(mktemp -d -p $pathname)
	trap "rm -rf $tempdir" EXIT
	tar -xf $filename -C $tempdir
	if [[ $paired_end == "True" ]];then
		if [ ! -f $tempdir/read_order_paired.bin.7z ];then
			echo "Not compressed using -e flag."
			usage
			exit 1
		fi
	elif [[ $preserve_order == "True" ]];then
		if [ ! -f $tempdir/read_order.bin.7z ];then
			echo "Not compressed using -p flag. Order cannot be restored"
			usage
			exit 1
		fi
	fi
	./$harcdir/bin/bsc d $tempdir/read_pos.tar.bsc $tempdir/read_pos.tar -t$num_thr
	./$harcdir/bin/bsc d $tempdir/read_noise.tar.bsc $tempdir/read_noise.tar -t$num_thr
	7z e $tempdir/read_noisepos.tar.7z -o$tempdir/
	./$harcdir/bin/bsc d $tempdir/unaligned_N.txt.bsc $tempdir/unaligned_N.txt -t$num_thr
	7z e $tempdir/read_meta.txt.7z -o$tempdir/
	7z e $tempdir/read_rev.tar.7z -o$tempdir/
	7z e $tempdir/numreads.bin.7z -o$tempdir/
	./$harcdir/bin/bsc d $tempdir/read_seq.tar.bsc $tempdir/read_seq.tar -t$num_thr
	./$harcdir/bin/bsc d $tempdir/unaligned_singleton.txt.bsc $tempdir/unaligned_singleton.txt -t$num_thr
	
	
	tar -xf $tempdir/read_pos.tar -C $tempdir/
	tar -xf $tempdir/read_noisepos.tar -C $tempdir/
	tar -xf $tempdir/read_noise.tar -C $tempdir/
	tar -xf $tempdir/read_rev.tar -C $tempdir/
	tar -xf $tempdir/read_seq.tar -C $tempdir/
	
	num_thr_e=$(ls $tempdir/read_pos.txt* | wc -l) #number of encoding threads
	readlen=$( cat $tempdir/read_meta.txt )
	#calculate bitset size for decoder
	bitset_size_decoder=$(((3*$readlen-1)/64*64+64))	
	mult32=$((($readlen-1)/32*32+32))	
	if [[ $paired_end == "True" ]];then
		7z e $tempdir/read_order_paired.bin.7z -o$tempdir/
		7z e $tempdir/read_paired_flag_first.bin.7z -o$tempdir/
		./$harcdir/bin/decoder_pe/decoder_pe_$bitset_size_decoder".out" $tempdir $readlen $memory $num_thr $num_thr_e
		mv $tempdir/output_1.dna $pathname/$(basename "$filename" .harc)_1.dna.d
		mv $tempdir/output_2.dna $pathname/$(basename "$filename" .harc)_2.dna.d
		echo "Done!"
	elif [[ $preserve_order == "True" ]];then
		7z e $tempdir/read_order.bin.7z -o$tempdir/
		./$harcdir/bin/unpack_order.out $tempdir
		./$harcdir/bin/decoder_preserve/decoder_preserve_$bitset_size_decoder".out" $tempdir $readlen $memory $num_thr $num_thr_e
		mv $tempdir/output.dna $pathname/$(basename "$filename" .harc).dna.d
		echo "Done!"
	else
		./$harcdir/bin/decoder.out $tempdir $num_thr $num_thr_e
		mv $tempdir/output.dna $pathname/$(basename "$filename" .harc).dna.d
	fi
	rm -r $tempdir/
}

#Initialize variables to default values.
num_thr=8

#Check the number of arguments. If none are passed, print help and exit.
NUMARGS=$#
if [ $NUMARGS -eq 0 ]; then
 usage
fi

mode=''
filename_2=''
preserve_order="False"
paired_end="False"
preserve_quality="False"
memory='7'

while getopts ':c:2:d:t:m:pqeh' opt; do
  case "$opt" in
    c) [[ -n "$mode" ]] && usage || mode='c' && filename=$OPTARG;;
    d) [[ -n "$mode" ]] && usage || mode='d' && filename=$OPTARG;;
    2) filename_2=$OPTARG;;	
    t) num_thr=$OPTARG;;
    m) memory=$OPTARG;;
    p) preserve_order="True";;
    e) paired_end="True";;	
    q) preserve_quality="True";;	
    h) usage ;;
    \?) usage ;;
    *) usage ;;
  esac
done

if [[ $mode == 'c' ]];then
compress
elif [[ $mode == 'd' ]];then
decompress
else
echo "Either -c or -d required"
usage
exit 1
fi;
